:PROPERTIES:
:ID:       83bdf269-bd9f-4749-9d9a-9948a4669c5e
:END:
# SPDX-FileCopyrightText: 2024 László Vaskó <vlaci@fastmail.com>
#
# SPDX-License-Identifier: EUPL-1.2
#+FILETAGS: :Emacs:
#+title: Emacs

I use Emacs for almost all general computing needs besides web
browsing. I used to maintain its configuration separately from my
machine configurations, but since I am moving to a more literate
approach, it makes sense to move it here.

#+caption: flake.nix:inputs
#+begin_src nix :noweb-ref flake-inputs
emacs-overlay.url = "github:nix-community/emacs-overlay";
#+end_src

Pass-in the input as a named argument to ~outputs~, so that it is available in modules:

I am wiring up my Emacs distribution using the ~withPackages~ function
described in the Nixpkgs Manual [[https://nixos.org/manual/nixpkgs/stable/#sec-emacs-config][here]]. Currently I am experimenting
retargeting ~user-emacs-directory~ to this repository, so I don't need
to rebuild ~Emacs~ every time I want to adjust its configuration.

#+begin_src nix :noweb no-export :noweb-ref local-packages
{
  vlaci-emacs =
    let
      inherit (pkgs) lib;
      pwd = builtins.getEnv "PWD";
      initDirectory = "${pwd}/out/emacs.d";
      dicts = with pkgs.hunspellDicts; [  # See jinx below
        hu-hu
        en-us-large
      ];
      dictSearchPath = lib.makeSearchPath "share/hunspell" dicts;
      overlaid = inputs.emacs-overlay.overlays.default pkgs pkgs;
      emacsWithPackages = inputs.emacs-overlay.lib.${pkgs.system}.emacsPackagesFor overlaid.emacs-igc-pgtk;

      emacs =
        (emacsWithPackages.overrideScope (
          lib.composeManyExtensions [
            (final: prev: {
            mkPackage =
              {
                pname,
                src,
                files ? [ "*.el" ],
                ...
              }@args:

              let
                files' =
                  let
                    list = lib.concatStringsSep " " (map (f: ''"${lib.escape [ ''"'' ] f}"'') files);
                  in
                  "(${list})";
                version =
                  let
                    ver = src.lastModifiedDate or inputs.self.lastModifiedDate;
                    removeLeadingZeros =
                      s:
                      let
                        s' = lib.removePrefix "0" s;
                      in
                      if lib.hasPrefix "0" s' then removeLeadingZeros s' else s';
                    major = removeLeadingZeros (builtins.substring 0 8 ver);
                    minor = removeLeadingZeros (builtins.substring 8 6 ver);
                  in
                  args.version or "${major}.${minor}";
              in
              final.melpaBuild (
                {
                  inherit version src;
                  commit =
                    src.rev or inputs.self.sourceInfo.rev or inputs.self.sourceInfo.dirtyRev
                      or "00000000000000000000000000000000";
                  recipe = pkgs.writeText "recipe" ''
                    (${pname}
                    :fetcher git
                    :url "nohost.nodomain"
                    :files ${files'})
                  '';
                }
                // removeAttrs args [ "files" ]
              );
            })
            <<emacs-package-overrides>>
          ]
        )).withPackages
          (
            epkgs:
            with epkgs;
            [
              <<emacs-packages>>
            ]
          );
      binaries = with pkgs; [
        <<emacs-nixpkgs>>
      ];
    in
    assert lib.assertMsg (pwd != "") "Use --impure flag for building";
    emacs.overrideAttrs (super: {
      # instead of relyiong on `package.el` to wire-up autoloads, do it build-time
      deps = super.deps.overrideAttrs (
        dsuper:
        let
          genAutoloadsCommand = ''
            echo "-- Generating autoloads..."
            autoloads=$out/share/emacs/site-lisp/autoloads.el
            for pkg in "''${requires[@]}"; do
              autoload=("$pkg"/share/emacs/site-lisp/*/*/*-autoloads.el)
              if [[ -e "$autoload" ]]; then
                cat "$autoload" >> "$autoloads"
              fi
            done
            echo "(load \"''$autoloads\")" >> "$siteStart"

            # Byte-compiling improves start-up time only slightly, but costs nothing.
            $emacs/bin/emacs --batch -f batch-byte-compile "$autoloads" "$siteStart"

            $emacs/bin/emacs --batch \
              --eval "(add-to-list 'native-comp-eln-load-path \"$out/share/emacs/native-lisp/\")" \
              -f batch-native-compile "$autoloads" "$siteStart"
          '';
        in
        {
          buildCommand = ''
            ${dsuper.buildCommand}
            ${genAutoloadsCommand}
          '';
        }
      );
      buildCommand = ''
        ${super.buildCommand}
        wrapProgram $out/bin/emacs \
          --append-flags "--init-directory ${initDirectory}" \
          --suffix PATH : ${
            with lib;
            pipe binaries [
              makeBinPath
              escapeShellArg
            ]
          } \
          --prefix DICPATH : ${lib.escapeShellArg dictSearchPath}
      '';
    });
}
#+end_src

Lets add it to installed packages:

#+begin_src nix :noweb-ref home-manager-modules :prologue "(" :epilogue ")"
{ pkgs, ... }:

{
  home.packages = [ pkgs.vlaci-emacs ];
}
#+end_src

#+begin_src nix :noweb-ref nixos-modules
{
  _.persist.allUsers.directories = [ ".cache/emacs" ];
}
#+end_src

Also, initialize the basics:

#+caption: erly-init.el
#+begin_src emacs-lisp :tangle out/emacs.d/early-init.el :mkdirp yes
;; -*- lexical-binding: t; -*-
(setq gc-cons-threshold most-positive-fixnum)

(add-hook 'after-init-hook
          `(lambda ()
             (setq file-name-handler-alist ',file-name-handler-alist))
          0)
(setq file-name-handler-alist nil)

(setq package-enable-at-startup nil
      frame-resize-pixelwise t
      frame-inhibit-implied-resize t
      frame-title-format '("%b")
      ring-bell-function 'ignore
      use-dialog-box nil
      use-file-dialog nil
      use-short-answers t
      inhibit-splash-screen t
      inhibit-startup-screen t
      inhibit-x-resources t
      inhibit-startup-echo-area-message user-login-name ; read the docstring
      inhibit-startup-buffer-menu t)

;; Prevent the glimpse of un-styled Emacs by disabling these UI elements early.
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)


(defvar user-cache-directory "~/.cache/emacs/"
  "Location where files created by emacs are placed.")

(defun vlaci/in-cache-directory (name)
  "Return NAME appended to cache directory"
  (expand-file-name name user-cache-directory))

(defvar vlaci/init-directory user-emacs-directory)

(defun vlaci/in-init-directory (name)
  "Return NAME appended to init directory"
  (expand-file-name name vlaci/init-directory))

(startup-redirect-eln-cache (vlaci/in-cache-directory "eln-cache"))

(setq user-emacs-directory user-cache-directory)
#+end_src


#+begin_src nix :noweb-ref emacs-package-overrides :prologue "(" :epilogue ")"
final: prev: {
  setup = prev.setup.overrideAttrs (_: {
    ignoreCompilationError = true;
  });
}
#+end_src

#+begin_src nix :noweb-ref emacs-packages
setup
gcmh
#+end_src

#+caption: init.el
#+begin_src emacs-lisp :noweb no-export :tangle out/emacs.d/init.el :mkdirp yes
;; -*- lexical-binding: t; -*-

;; Use font from Gsettings from /org/gnome/desktop/interface/
;; The keys read are:
;;  - ‘font-name’
;;  - 'monospace-font-name’
(require 'vlaci-emacs)

(setq font-use-system-font t)
(set-face-attribute 'fixed-pitch nil :height 1.0)
(set-face-attribute 'variable-pitch nil :height 1.0)

(setup (:package gcmh)
  (:hook-into on-first-buffer-hook)
  (:option gcmh-verbose init-file-debug
           gcmh-high-cons-threshold (* 128 1024 1024)))

(setup emacs
  (setq user-emacs-directory user-cache-directory)
  (:option
   custom-file (vlaci/in-cache-directory "custom.el")
   auto-save-interval 2400
   auto-save-timeout 300
   auto-save-list-file-name (vlaci/in-cache-directory "auto-save.lst")
   auto-save-file-name-transforms `((".*" ,(vlaci/in-cache-directory "auto-save/") t))
   backup-directory-alist `(("." . ,(vlaci/in-cache-directory "backup/")))
   backup-by-copying t
   version-control t
   delete-old-versions t
   kept-new-versions 10
   kept-old-versions 5)

  (make-directory (vlaci/in-cache-directory "auto-save/") :parents)

  (load custom-file :no-error-if-file-is-missing))


(setup recentf
  (:option recentf-max-saved-items 200
           recentf-auto-cleanup 300)
  (define-advice recentf-cleanup (:around (fun) silently)
    (let ((inhibit-message t)
          (message-log-max nil))
      (funcall fun)))
  (recentf-mode 1))

(setup savehist
  (:hook-into on-first-file-hook)
  (:option history-length 1000
           history-delete-duplicates t
           savehist-save-minibuffer-history t
           savehist-additional-variables
            '(kill-ring                            ; clipboard
              register-alist                       ; macros
              mark-ring global-mark-ring           ; marks
              search-ring regexp-search-ring)))    ; searches

(setup save-place
  (:hook-into on-first-file-hook)
  (:option save-place-limit 600))

<<init-el>>
#+end_src


#+caption: home-manager
#+begin_src nix :noweb-ref home-manager-modules :prologue "(" :epilogue ")"
{ pkgs, ... }:

let
  e = pkgs.writeShellScriptBin "e" ''
    if [ -n "$INSIDE_EMACS" ]; then
      emacsclient -n "$@"
    else
      emacsclient --alternate-editor="" -t "$@"
    fi
  '';
in
{
  home.sessionVariables.EDITOR = e;
  home.packages = [ e ];
}
#+end_src

** My helper package

This contains my to-be compiled code to keep ~init.el~ clean.

#+begin_src nix :noweb no-export :noweb-ref emacs-packages :prologue "(" :epilogue ")"
mkPackage {
  pname = "vlaci-emacs";
  version = "1.0";
  src = pkgs.writeText "vlaci-emacs.el" ''
    ;;; vlaci-emacs.el --- local extensions -*- lexical-binding: t; -*-

    <<vlaci-emacs>>
    (provide 'vlaci-emacs)
  '';

  packageRequires = [
    <<vlaci-emacs-requires>>
  ];
}
#+end_src

** Help

#+begin_src emacs-lisp :noweb-ref init-el
(setup emacs
  (:option help-window-keep-selected t)) ;; navigating to e.g. source from help window reuses said window
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup which-key
  (:option which-key-popup-type 'minibuffer) ;; required for embark-prefix-command (C-h) to work
  (:hook-into on-first-input-hook))
#+end_src

#+begin_src nix :noweb-ref emacs-packages
helpful
elisp-demos
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package helpful elisp-demos)
  (:option help-window-select t)
  (:global
   [remap describe-command] #'helpful-command
   [remap describe-function] #'helpful-callable
   [remap describe-macro] #'helpful-macro
   [remap describe-key] #'helpful-key
   [remap describe-symbol] #'helpful-symbol
   [remap describe-variable] #'helpful-variable)
  (:when-loaded
    (require 'elisp-demos)
    (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update)))
#+end_src

** More hooks

#+caption: packages
#+begin_src nix :noweb-ref emacs-packages
on
#+end_src


#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package on)
  (:require on))
#+end_src

** UI

#+begin_src emacs-lisp :noweb-ref init-el
(setup emacs
  (:global [remap kill-buffer] #'kill-current-buffer))
#+end_src

#+begin_src nix :noweb-ref emacs-packages
auto-dark
spacious-padding
ef-themes
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package auto-dark spacious-padding)
  (:option spacious-padding-subtle-mode-line t
           spacious-padding-widths
           '( :internal-border-width 15
              :header-line-width 4
              :mode-line-width 6
              :tab-width 4
              :right-divider-width 1
              :scroll-bar-width 8
              :fringe-width 8)
           auto-dark-themes '((modus-vivendi-tinted) (modus-operandi-tinted)))
  (defun vlaci--load-theme-h ()
    (require-theme 'modus-themes)
    (setq modus-themes-italic-constructs t
          modus-themes-bold-constructs t
          modus-themes-prompts '(background)
          modus-themes-mixed-fonts nil
          modus-themes-org-blocks 'gray-background
          modus-themes-headings '((0 . (2.0))
                                  (1 . (rainbow background overline 1.5))
                                  (2 . (background overline 1.4))
                                  (3 . (background overline 1.3))
                                  (4 . (background overline 1.2))
                                  (5 . (overline 1.2))
                                  (t . (no-bold 1.1)))
          modus-themes-common-palette-overrides
          `(,@modus-themes-preset-overrides-faint
            (builtin magenta)
            (comment fg-dim)
            (constant magenta-cooler)
            (docstring magenta-faint)
            (docmarkup green-faint)
            (fnname magenta-warmer)
            (keyword cyan)
            (preprocessor cyan-cooler)
            (string red-cooler)
            (type magenta-cooler)
            (variable blue-warmer)
            (rx-construct magenta-warmer)
            (rx-backslash blue-cooler)))
    (load-theme 'modus-operandi-tinted :no-confirm)
    (spacious-padding-mode)
    (auto-dark-mode))
  (:with-function vlaci--load-theme-h
    (:hook-into window-setup-hook)))
#+end_src

#+begin_src nix :noweb-ref emacs-packages
repeat-help
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package repeat-help)
  (:hook-into repeat-mode-hook)
  (:hook (defun vlaci/reset-repeat-echo-function-h ()
           (setq repeat-echo-function repeat-help--echo-function))))

(setup repeat
  (:hook-into on-first-input-hook))
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup emacs
  (:option display-line-numbers-type 'relative
           display-line-numbers-width 3
           display-line-numbers-widen t
           split-width-threshold 170
           truncate-lines t
           window-combination-resize t))

(setup prog
  (:hook #'display-line-numbers-mode))
#+end_src


#+begin_src nix :noweb-ref emacs-packages
lin
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package lin)
  (:with-mode lin-global-mode
    (:hook-into on-first-buffer-hook)))
#+end_src

*** Modeline

#+begin_src emacs-lisp :noweb-ref init-el
(setup emacs
  (:option
  mode-line-compact nil ; Emacs 28
  mode-line-right-align-edge 'right-margin) ; Emacs 30
  (setq-default mode-line-format
                '("%e"
                  vl-modeline-kbd-macro
                  vl-modeline-narrow
                  vl-modeline-buffer-status
                  vl-modeline-evil
                  vl-modeline-window-dedicated-status
                  vl-modeline-input-method
                  "  "
                  vl-modeline-buffer-identification
                  "  "
                  vl-modeline-major-mode
                  vl-modeline-process
                  "  "
                  vl-modeline-vc-branch
                  "  "
                  vl-modeline-lsp
                  "  "
                  vl-modeline-flymake
                  "  "
                  mode-line-format-right-align ; Emacs 30
                  vl-modeline-notmuch-indicator
                  "  "
                  vl-modeline-misc-info))

  (:with-feature spacious-padding
    (:when-loaded
    (defun vl/modeline-spacious-indicators ()
      (if (bound-and-true-p spacious-padding-mode)
          (set-face-attribute 'vl-modeline-indicator-button nil :box t)
        (set-face-attribute 'vl-modeline-indicator-button nil :box 'unspecified)))

    ;; Run it at startup and then afterwards whenever
    ;; `spacious-padding-mode' is toggled on/off.
    (vl/modeline-spacious-indicators)

    (add-hook 'spacious-padding-mode-hook #'vl/modeline-spacious-indicators))))

(defvar vl-modeline-string-truncate-length 15)

;;;; Faces

(defface vl-modeline-indicator-button nil
  "Generic face used for indicators that have a background.
Modify this face to, for example, add a :box attribute to all
relevant indicators (combines nicely with my `spacious-padding'
package).")

(defface vl-modeline-indicator-red
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#880000")
    (((class color) (min-colors 88) (background dark))
     :foreground "#ff9f9f")
    (t :foreground "red"))
  "Face for modeline indicators (e.g. see my `notmuch-indicator')."
  :group 'vl-modeline-faces)

(defface vl-modeline-indicator-red-bg
  '((default :inherit (bold vl-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#aa1111" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#ff9090" :foreground "black")
    (t :background "red" :foreground "black"))
  "Face for modeline indicators with a background."
  :group 'vl-modeline-faces)

(defface vl-modeline-indicator-green
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#005f00")
    (((class color) (min-colors 88) (background dark))
     :foreground "#73fa7f")
    (t :foreground "green"))
  "Face for modeline indicators (e.g. see my `notmuch-indicator')."
  :group 'vl-modeline-faces)

(defface vl-modeline-indicator-green-bg
  '((default :inherit (bold vl-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#207b20" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#77d077" :foreground "black")
    (t :background "green" :foreground "black"))
  "Face for modeline indicators with a background."
  :group 'vl-modeline-faces)

(defface vl-modeline-indicator-yellow
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#6f4000")
    (((class color) (min-colors 88) (background dark))
     :foreground "#f0c526")
    (t :foreground "yellow"))
  "Face for modeline indicators (e.g. see my `notmuch-indicator')."
  :group 'vl-modeline-faces)

(defface vl-modeline-indicator-yellow-bg
  '((default :inherit (bold vl-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#805000" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#ffc800" :foreground "black")
    (t :background "yellow" :foreground "black"))
  "Face for modeline indicators with a background."
  :group 'vl-modeline-faces)

(defface vl-modeline-indicator-blue
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#00228a")
    (((class color) (min-colors 88) (background dark))
     :foreground "#88bfff")
    (t :foreground "blue"))
  "Face for modeline indicators (e.g. see my `notmuch-indicator')."
  :group 'vl-modeline-faces)

(defface vl-modeline-indicator-blue-bg
  '((default :inherit (bold vl-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#0000aa" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#77aaff" :foreground "black")
    (t :background "blue" :foreground "black"))
  "Face for modeline indicators with a background."
  :group 'vl-modeline-faces)

(defface vl-modeline-indicator-magenta
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#6a1aaf")
    (((class color) (min-colors 88) (background dark))
     :foreground "#e0a0ff")
    (t :foreground "magenta"))
  "Face for modeline indicators (e.g. see my `notmuch-indicator')."
  :group 'vl-modeline-faces)

(defface vl-modeline-indicator-magenta-bg
  '((default :inherit (bold vl-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#6f0f9f" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#e3a2ff" :foreground "black")
    (t :background "magenta" :foreground "black"))
  "Face for modeline indicators with a background."
  :group 'vl-modeline-faces)

(defface vl-modeline-indicator-cyan
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#004060")
    (((class color) (min-colors 88) (background dark))
     :foreground "#30b7cc")
    (t :foreground "cyan"))
  "Face for modeline indicators (e.g. see my `notmuch-indicator')."
  :group 'vl-modeline-faces)

(defface vl-modeline-indicator-cyan-bg
  '((default :inherit (bold vl-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#006080" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#40c0e0" :foreground "black")
    (t :background "cyan" :foreground "black"))
  "Face for modeline indicators with a background."
  :group 'vl-modeline-faces)

(defface vl-modeline-indicator-gray
  '((t :inherit shadow))
  "Face for modeline indicators (e.g. see my `notmuch-indicator')."
  :group 'vl-modeline-faces)

(defface vl-modeline-indicator-gray-bg
  '((default :inherit (bold vl-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#808080" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#a0a0a0" :foreground "black")
    (t :inverse-video t))
  "Face for modeline indicatovrs with a background."
  :group 'vl-modeline-faces)

;;;; Common helper functions

(defun vl-common-window-narrow-p ()
  "Return non-nil if window is narrow.
Check if the `window-width' is less than `split-width-threshold'."
  (and (numberp split-width-threshold)
       (< (window-total-width) split-width-threshold)))

(defun vl-modeline--string-truncate-p (str)
  "Return non-nil if STR should be truncated."
  (cond
   ((or (not (stringp str))
        (string-empty-p str)
        (string-blank-p str))
    nil)
   ((and (vl-common-window-narrow-p)
         (> (length str) vl-modeline-string-truncate-length)
         (not (one-window-p :no-minibuffer))))))

(defun vl-modeline--truncate-p ()
  "Return non-nil if truncation should happen.
This is a more general and less stringent variant of
`vl-modeline--string-truncate-p'."
  (and (vl-common-window-narrow-p)
       (not (one-window-p :no-minibuffer))))

(defun vl-modeline-string-cut-end (str)
  "Return truncated STR, if appropriate, else return STR.
Cut off the end of STR by counting from its start up to
`vl-modeline-string-truncate-length'."
  (if (vl-modeline--string-truncate-p str)
      (concat (substring str 0 vl-modeline-string-truncate-length) "...")
    str))

(defun vl-modeline-string-cut-beginning (str)
  "Return truncated STR, if appropriate, else return STR.
Cut off the beginning of STR by counting from its end up to
`vl-modeline-string-truncate-length'."
  (if (vl-modeline--string-truncate-p str)
      (concat "..." (substring str (- vl-modeline-string-truncate-length)))
    str))

(defun vl-modeline-string-cut-middle (str)
  "Return truncated STR, if appropriate, else return STR.
Cut off the middle of STR by counting half of
`vl-modeline-string-truncate-length' both from its beginning
and end."
  (let ((half (floor vl-modeline-string-truncate-length 2)))
    (if (vl-modeline--string-truncate-p str)
        (concat (substring str 0 half) "..." (substring str (- half)))
      str)))

(defun vl-modeline--first-char (str)
  "Return first character from STR."
  (substring str 0 1))

(defun vl-modeline-string-abbreviate (str)
  "Abbreviate STR individual hyphen or underscore separated words.
Also see `vl-modeline-string-abbreviate-but-last'."
  (if (vl-modeline--string-truncate-p str)
      (mapconcat #'vl-modeline--first-char (split-string str "[_-]") "-")
    str))

(defun vl-modeline-string-abbreviate-but-last (str nthlast)
  "Abbreviate STR, keeping NTHLAST words intact.
Also see `vl-modeline-string-abbreviate'."
  (if (vl-modeline--string-truncate-p str)
      (let* ((all-strings (split-string str "[_-]"))
             (nbutlast-strings (nbutlast (copy-sequence all-strings) nthlast))
             (last-strings (nreverse (ntake nthlast (nreverse (copy-sequence all-strings)))))
             (first-component (mapconcat #'vl-modeline--first-char nbutlast-strings "-"))
             (last-component (mapconcat #'identity last-strings "-")))
        (if (string-empty-p first-component)
            last-component
          (concat first-component "-" last-component)))
    str))

;;;; Keyboard macro indicator

(defvar-local vl-modeline-kbd-macro
    '(:eval
      (when (and (mode-line-window-selected-p) defining-kbd-macro)
        (propertize " KMacro " 'face 'vl-modeline-indicator-blue-bg)))
  "Mode line construct displaying `mode-line-defining-kbd-macro'.
Specific to the current window's mode line.")

;;;; Narrow indicator

(defvar-local vl-modeline-narrow
    '(:eval
      (when (and (mode-line-window-selected-p)
                 (buffer-narrowed-p)
                 (not (derived-mode-p 'Info-mode 'help-mode 'special-mode 'message-mode)))
        (propertize " Narrow " 'face 'vl-modeline-indicator-cyan-bg)))
  "Mode line construct to report the narrowed state of the current buffer.")

;;;; Input method

(defvar-local vl-modeline-input-method
    '(:eval
      (when current-input-method-title
        (propertize (format " %s " current-input-method-title)
                    'face 'vl-modeline-indicator-green-bg
                    'mouse-face 'mode-line-highlight)))
  "Mode line construct to report the multilingual environment.")

;;;; Buffer status

;; TODO 2023-07-05: What else is there beside remote files?  If
;; nothing, this must be renamed accordingly.
(defvar-local vl-modeline-buffer-status
    '(:eval
      (when (file-remote-p default-directory)
        (propertize " @ "
                    'face 'vl-modeline-indicator-red-bg
                    'mouse-face 'mode-line-highlight)))
  "Mode line construct for showing remote file name.")

;;;; Evil

(defvar evil-state)
(defvar evil-visual-selection)

(defconst vl-modeline-evil-state-tags
  '((normal   :icon "nf-md-alpha_n_box" :face 'vl-modeline-indicator-blue)
    (insert   :icon "nf-md-alpha_i_box" :face 'vl-modeline-indicator-red)
    (visual   :icon "nf-md-alpha_v_box" :face 'vl-modeline-indicator-yellow)
    (vblock   :icon "nf-md-alpha_b_box" :face 'vl-modeline-indicator-yellow)
    (vline    :icon "nf-md-alpha_l_box" :face 'vl-modeline-indicator-yellow)
    (vsline   :icon "nf-md-alpha_l_box_outline" :face 'vl-modeline-indicator-yellow)
    (motion   :icon "nf-md-alpha_m_box" :face 'vl-modeline-indicator-yellow)
    (emacs    :icon "nf-md-alpha_e_box" :face 'vl-modeline-indicator-magenta)
    (operator :icon "nf-md-alpha_o_box" :face 'vl-modeline-indicator-red)
    (replace  :icon "nf-md-alpha_r_box" :face 'vl-modeline-indicator-red))
  "Short and long tags for Evil states.")

(defun vl-modeline-evil-state-tag ()
  "Return mode line tag VARIANT depending on the Evil state.
VARIANT of the state tag is either :short or :long, as defined in
`vl-modeline-evil-state-tags'."
  (let* ((state (pcase evil-state
                  ('visual (pcase evil-visual-selection
                             ('line 'vline)
                             ('screen-line)
                             ('block 'vblock)
                             (_ 'visual)))
                  (_ evil-state)))
         (fmt (alist-get state vl-modeline-evil-state-tags)))
    (propertize
     (vl-propertize-icon (nerd-icons-mdicon (plist-get fmt :icon)) (plist-get fmt :face))
     'mouse-face
     'mode-line-highlight
     'help-echo (evil-state-property evil-state :name t))))

(defun vl-propertize-icon (icon face)
  (when-let* ((props (get-text-property 0 'face icon)))
    (when (listp props)
      (cl-destructuring-bind (&key family height inherit &allow-other-keys) props
        (propertize icon 'face `(:inherit ,(or face inherit props)
                                          :family  ,(or family "")
                                          :height  ,(or height 1.0)))))))

(defvar-local vl-modeline-evil
    '(:eval
      (when (and (mode-line-window-selected-p) (bound-and-true-p evil-mode))
          (vl-modeline-evil-state-tag)))
  "Mode line construct to display the Evil state.")

;;;; Dedicated window

(defvar-local vl-modeline-window-dedicated-status
    '(:eval
      (when (window-dedicated-p)
        (propertize " = "
                    'face 'vl-modeline-indicator-gray-bg
                    'mouse-face 'mode-line-highlight)))
  "Mode line construct for dedicated window indicator.")

;;;; Buffer name and modified status

(defun vl-modeline-buffer-identification-face ()
  "Return appropriate face or face list for `vl-modeline-buffer-identification'."
  (let ((file (buffer-file-name)))
    (cond
     ((and (mode-line-window-selected-p)
           file
           (buffer-modified-p))
      '(italic mode-line-buffer-id))
     ((and file (buffer-modified-p))
      'italic)
     ((mode-line-window-selected-p)
      'mode-line-buffer-id))))

(defun vl-modeline--buffer-name ()
  "Return `buffer-name', truncating it if necessary.
See `vl-modeline-string-cut-middle'."
  (when-let* ((name (buffer-name)))
    (vl-modeline-string-cut-middle name)))

(defun vl-modeline-buffer-name ()
  "Return buffer name, with read-only indicator if relevant."
  (let ((name (vl-modeline--buffer-name)))
    (if buffer-read-only
        (format "%s ff %s ff %s" (char-to-string #xE0A2) (nerd-icons-icon-for-buffer) name)
      name)))

(defun vl-modeline-buffer-name-help-echo ()
  "Return `help-echo' value for `vl-modeline-buffer-identification'."
  (concat
   (propertize (buffer-name) 'face 'mode-line-buffer-id)
   "\n"
   (propertize
    (or (buffer-file-name)
        (format "No underlying file.\nDirectory is: %s" default-directory))
    'face 'font-lock-doc-face)))

(defvar-local vl-modeline-buffer-identification
    '(:eval
      (propertize (vl-modeline-buffer-name)
                  'face (vl-modeline-buffer-identification-face)
                  'mouse-face 'mode-line-highlight
                  'help-echo (vl-modeline-buffer-name-help-echo)))
  "Mode line construct for identifying the buffer being displayed.
Propertize the current buffer with the `mode-line-buffer-id'
face.  Let other buffers have no face.")

;;;; Major mode

(defun vl-modeline-major-mode-indicator ()
  "Return appropriate propertized mode line indicator for the major mode."
  (let ((indicator (cond
                    ((derived-mode-p 'text-mode) "§")
                    ((derived-mode-p 'prog-mode) "λ")
                    ((derived-mode-p 'comint-mode) ">_")
                    (t "◦"))))
    (propertize indicator 'face 'shadow)))

(defun vl-modeline-major-mode-name ()
  "Return capitalized `major-mode' without the -mode suffix."
  (capitalize (string-replace "-mode" "" (symbol-name major-mode))))

(defun vl-modeline-major-mode-help-echo ()
  "Return `help-echo' value for `vl-modeline-major-mode'."
  (if-let* ((parent (get major-mode 'derived-mode-parent)))
      (format "Symbol: `%s'.  Derived from: `%s'" major-mode parent)
    (format "Symbol: `%s'." major-mode)))

(defvar-local vl-modeline-major-mode
    (list
     (propertize "%[" 'face 'vl-modeline-indicator-red)
     '(:eval
       (concat
        (vl-modeline-major-mode-indicator)
        " "
        (propertize
         (vl-modeline-string-abbreviate-but-last
          (vl-modeline-major-mode-name)
          2)
         'mouse-face 'mode-line-highlight
         'help-echo (vl-modeline-major-mode-help-echo))))
     (propertize "%]" 'face 'vl-modeline-indicator-red))
  "Mode line construct for displaying major modes.")

(defvar-local vl-modeline-process
    (list '("" mode-line-process))
  "Mode line construct for the running process indicator.")

;;;; Git branch and diffstat

(declare-function vc-git--symbolic-ref "vc-git" (file))

(defun vl-modeline--vc-branch-name (file backend)
  "Return capitalized VC branch name for FILE with BACKEND."
  (when-let* ((rev (vc-working-revision file backend))
              (branch (or (vc-git--symbolic-ref file)
                          (substring rev 0 7))))
    (capitalize branch)))

;; NOTE 2023-07-27: This is a good idea, but it hardcodes Git, whereas
;; I want a generic VC method.  Granted, I only use Git but I still
;; want it to work as a VC extension.

;; (defun vl-modeline-diffstat (file)
;;   "Return shortened Git diff numstat for FILE."
;;   (when-let* ((output (shell-command-to-string (format "git diff --numstat %s" file)))
;;               (stats (split-string output "[\s\t]" :omit-nulls "[\s\f\t\n\r\v]+"))
;;               (added (nth 0 stats))
;;               (deleted (nth 1 stats)))
;;     (cond
;;      ((and (equal added "0") (equal deleted "0"))
;;       "")
;;      ((and (not (equal added "0")) (equal deleted "0"))
;;       (propertize (format "+%s" added) 'face 'shadow))
;;      ((and (equal added "0") (not (equal deleted "0")))
;;       (propertize (format "-%s" deleted) 'face 'shadow))
;;      (t
;;       (propertize (format "+%s -%s" added deleted) 'face 'shadow)))))

(declare-function vc-git-working-revision "vc-git" (file))

(defvar vl-modeline-vc-map
  (let ((map (make-sparse-keymap)))
    (define-key map [mode-line down-mouse-1] 'vc-diff)
    (define-key map [mode-line down-mouse-3] 'vc-root-diff)
    map)
  "Keymap to display on VC indicator.")

(defun vl-modeline--vc-help-echo (file)
  "Return `help-echo' message for FILE tracked by VC."
  (format "Revision: %s\nmouse-1: `vc-diff'\nmouse-3: `vc-root-diff'"
          (vc-working-revision file)))

(defun vl-modeline--vc-text (file branch &optional face)
  "Prepare text for Git controlled FILE, given BRANCH.
With optional FACE, use it to propertize the BRANCH."
  (concat
   (propertize (char-to-string #xE0A0) 'face 'shadow)
   " "
   (propertize branch
               'face face
               'mouse-face 'mode-line-highlight
               'help-echo (vl-modeline--vc-help-echo file)
               'local-map vl-modeline-vc-map)
   ;; " "
   ;; (vl-modeline-diffstat file)
   ))

(defun vl-modeline--vc-details (file branch &optional face)
  "Return Git BRANCH details for FILE, truncating it if necessary.
The string is truncated if the width of the window is smaller
than `split-width-threshold'."
  (vl-modeline-string-cut-end
   (vl-modeline--vc-text file branch face)))

(defvar vl-modeline--vc-faces
  '((added . vc-locally-added-state)
    (edited . vc-edited-state)
    (removed . vc-removed-state)
    (missing . vc-missing-state)
    (conflict . vc-conflict-state)
    (locked . vc-locked-state)
    (up-to-date . vc-up-to-date-state))
  "VC state faces.")

(defun vl-modeline--vc-get-face (key)
  "Get face from KEY in `vl-modeline--vc-faces'."
  (alist-get key vl-modeline--vc-faces 'vc-up-to-date-state))

(defun vl-modeline--vc-face (file backend)
  "Return VC state face for FILE with BACKEND."
  (when-let* ((key (vc-state file backend)))
    (vl-modeline--vc-get-face key)))

(defvar-local vl-modeline-vc-branch
    '(:eval
      (when-let* (((mode-line-window-selected-p))
                  (file (or buffer-file-name default-directory))
                  (backend (or (vc-backend file) 'Git))
                  ;; ((vc-git-registered file))
                  (branch (vl-modeline--vc-branch-name file backend))
                  (face (vl-modeline--vc-face file backend)))
        (vl-modeline--vc-details file branch face)))
  "Mode line construct to return propertized VC branch.")

;;;; Flymake errors, warnings, notes

(declare-function flymake--severity "flymake" (type))
(declare-function flymake-diagnostic-type "flymake" (diag))

;; Based on `flymake--mode-line-counter'.
(defun vl-modeline-flymake-counter (type)
  "Compute number of diagnostics in buffer with TYPE's severity.
TYPE is usually keyword `:error', `:warning' or `:note'."
  (let ((count 0))
    (dolist (d (flymake-diagnostics))
      (when (= (flymake--severity type)
               (flymake--severity (flymake-diagnostic-type d)))
        (cl-incf count)))
    (when (cl-plusp count)
      (number-to-string count))))

(defvar vl-modeline-flymake-map
  (let ((map (make-sparse-keymap)))
    (define-key map [mode-line down-mouse-1] 'flymake-show-buffer-diagnostics)
    (define-key map [mode-line down-mouse-3] 'flymake-show-project-diagnostics)
    map)
  "Keymap to display on Flymake indicator.")

(defmacro vl-modeline-flymake-type (type indicator &optional face)
  "Return function that handles Flymake TYPE with stylistic INDICATOR and FACE."
  `(defun ,(intern (format "vl-modeline-flymake-%s" type)) ()
     (when-let* ((count (vl-modeline-flymake-counter
                         ,(intern (format ":%s" type)))))
       (concat
        (propertize ,indicator 'face 'shadow)
        (propertize count
                    'face ',(or face type)
                    'mouse-face 'mode-line-highlight
                    ;; FIXME 2023-07-03: Clicking on the text with
                    ;; this buffer and a single warning present, the
                    ;; diagnostics take up the entire frame.  Why?
                    'local-map vl-modeline-flymake-map
                    'help-echo "mouse-1: buffer diagnostics\nmouse-3: project diagnostics")))))

(vl-modeline-flymake-type error "☣")
(vl-modeline-flymake-type warning "!")
(vl-modeline-flymake-type note "·" success)

(defvar-local vl-modeline-flymake
    `(:eval
      (when (and (bound-and-true-p flymake-mode)
                 (mode-line-window-selected-p))
        (list
         ;; See the calls to the macro `vl-modeline-flymake-type'
         '(:eval (vl-modeline-flymake-error))
         '(:eval (vl-modeline-flymake-warning))
         '(:eval (vl-modeline-flymake-note)))))
  "Mode line construct displaying `flymake-mode-line-format'.
Specific to the current window's mode line.")

;;;; LSP

(defvar-local vl-modeline-lsp nil)
(defun vl-modeline-update-lsp (&rest _)
  "Update `lsp-mode' state."
  (setq vl-modeline-lsp
        (let* ((workspaces (lsp-workspaces))
               (face (if workspaces 'vl-modeline-indicator-green 'vl-modeline-indicator-yellow))
               (icon "LSP"))
          (propertize icon
                      'help-echo
                      (if workspaces
                          (concat "LSP connected "
                                  (string-join
                                   (mapcar (lambda (w)
                                             (format "[%s]\n" (lsp--workspace-print w)))
                                           workspaces))
                                  "C-mouse-1: Switch to another workspace folder
mouse-1: Describe current session
mouse-2: Quit server
mouse-3: Reconnect to server")
                        "LSP Disconnected
mouse-1: Reload to start server")
                      'mouse-face 'mode-line-highlight
                      'local-map (let ((map (make-sparse-keymap)))
                                   (if workspaces
                                       (progn
                                         (define-key map [mode-line C-mouse-1]
                                           #'lsp-workspace-folders-open)
                                         (define-key map [mode-line mouse-1]
                                           #'lsp-describe-session)
                                         (define-key map [mode-line mouse-2]
                                           #'lsp-workspace-shutdown)
                                         (define-key map [mode-line mouse-3]
                                           #'lsp-workspace-restart))
                                     (progn
                                       (define-key map [mode-line mouse-1]
                                         (lambda ()
                                           (interactive)
                                           (ignore-errors (revert-buffer t t))))))
                                   map)))))
(add-hook 'lsp-before-initialize-hook #'vl-modeline-update-lsp)
(add-hook 'lsp-after-initialize-hook #'vl-modeline-update-lsp)
(add-hook 'lsp-after-uninitialized-functions #'vl-modeline-update-lsp)
(add-hook 'lsp-before-open-hook #'vl-modeline-update-lsp)
(add-hook 'lsp-after-open-hook #'vl-modeline-update-lsp)


(defvar-local vl-modeline-misc-info
    '(:eval
      (when (mode-line-window-selected-p)
        mode-line-misc-info))
  "Mode line construct displaying `mode-line-misc-info'.
Specific to the current window's mode line.")

;;;; Risky local variables

;; NOTE 2023-04-28: The `risky-local-variable' is critical, as those
;; variables will not work without it.
(dolist (construct '(vl-modeline-kbd-macro
                     vl-modeline-narrow
                     vl-modeline-input-method
                     vl-modeline-buffer-status
                     vl-modeline-evil
                     vl-modeline-window-dedicated-status
                     vl-modeline-buffer-identification
                     vl-modeline-major-mode
                     vl-modeline-process
                     vl-modeline-vc-branch
                     vl-modeline-flymake
                     vl-modeline-lsp
                     vl-modeline-notmuch-indicator
                     vl-modeline-misc-info))
  (put construct 'risky-local-variable t))

#+end_src

** More fine grained lazy loading

#+begin_src nix :noweb-ref flake-inputs
once = { url = "github:emacs-magus/once"; flake = false; };
#+end_src

#+begin_src nix :noweb-ref emacs-packages :prologue "(" :epilogue ")"
mkPackage {
  pname = "once";
  src = inputs.once;
  files = [
    "*.el"
    "once-setup/*.el"
  ];
  packageRequires = [
    (setup.overrideAttrs (_: {
      ignoreCompilationError = true;
    }))
  ];
}
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package once)
  (:option once-shorthand t)
  (:require once once-conditions))

(setup (:package once-setup)
  (:require once-setup))
#+end_src

;; https://github.com/hlissner/doom-emacs/blob/42a21dffddeee57d84e82a9f0b65d1b0cba2b2af/core/core.el#L353

#+begin_src nix :noweb-ref vlaci-emacs-requires
setup
#+end_src

#+begin_src emacs-lisp :noweb-ref vlaci-emacs
(defvar vlaci-incremental-packages '(t)
  "A list of packages to load incrementally after startup. Any large packages
here may cause noticeable pauses, so it's recommended you break them up into
sub-packages. For example, `org' is comprised of many packages, and can be
broken up into:
  (vlaci-load-packages-incrementally
   '(calendar find-func format-spec org-macs org-compat
     org-faces org-entities org-list org-pcomplete org-src
     org-footnote org-macro ob org org-clock org-agenda
     org-capture))
This is already done by the lang/org module, however.
If you want to disable incremental loading altogether, either remove
`doom-load-packages-incrementally-h' from `emacs-startup-hook' or set
`doom-incremental-first-idle-timer' to nil.")

(defvar vlaci-incremental-first-idle-timer 2.0
  "How long (in idle seconds) until incremental loading starts.
Set this to nil to disable incremental loading.")

(defvar vlaci-incremental-idle-timer 0.75
  "How long (in idle seconds) in between incrementally loading packages.")

(defvar vlaci-incremental-load-immediately nil
  ;; (daemonp)
  "If non-nil, load all incrementally deferred packages immediately at startup.")

(defun vlaci-load-packages-incrementally (packages &optional now)
  "Registers PACKAGES to be loaded incrementally.
If NOW is non-nil, load PACKAGES incrementally, in `doom-incremental-idle-timer'
intervals."
  (if (not now)
      (setq vlaci-incremental-packages (append vlaci-incremental-packages packages))
    (while packages
      (let ((req (pop packages)))
        (unless (featurep req)
          (message "Incrementally loading %s" req)
          (condition-case e
              (or (while-no-input
                    ;; If `default-directory' is a directory that doesn't exist
                    ;; or is unreadable, Emacs throws up file-missing errors, so
                    ;; we set it to a directory we know exists and is readable.
                    (let ((default-directory user-emacs-directory)
                          (gc-cons-threshold most-positive-fixnum)
                          file-name-handler-alist)
                      (require req nil t))
                    t)
                  (push req packages))
            ((error debug)
             (message "Failed to load '%s' package incrementally, because: %s"
                      req e)))
          (if (not packages)
              (message "Finished incremental loading")
            (run-with-idle-timer vlaci-incremental-idle-timer
                                 nil #'vlaci-load-packages-incrementally
                                 packages t)
            (setq packages nil)))))))

;;;###autoload
(defun vlaci-load-packages-incrementally-h ()
  "Begin incrementally loading packages in `vlaci-incremental-packages'.
If this is a daemon session, load them all immediately instead."
  (if vlaci-incremental-load-immediately
      (mapc #'require (cdr vlaci-incremental-packages))
    (when (numberp vlaci-incremental-first-idle-timer)
      (run-with-idle-timer vlaci-incremental-first-idle-timer
                           nil #'vlaci-load-packages-incrementally
                           (cdr vlaci-incremental-packages) t))))

(add-hook 'emacs-startup-hook #'vlaci-load-packages-incrementally-h)

(require 'setup)

(setup-define :package
  (lambda (package))
  :documentation "Fake installation of PACKAGE."
  :repeatable t
  :shorthand #'cadr)

(setup-define :defer-incrementally
  (lambda (&rest targets)
  (vlaci-load-packages-incrementally targets)
   :documentation "Load TARGETS incrementally"))
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup-define :autoload
  (lambda (func)
    (let ((fn (if (memq (car-safe func) '(quote function))
                  (cadr func)
                func)))
      `(unless (fboundp (quote ,fn))
         (autoload (function ,fn) ,(symbol-name (setup-get 'feature)) nil t))))
  :documentation "Autoload COMMAND if not already bound."
  :repeatable t
  :signature '(FUNC ...))
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup emacs
  (defun vl/welcome ()
    (with-current-buffer (get-buffer-create "*scratch*")
      (insert (format ";;
;; ██╗   ██╗██╗        ███████╗███╗   ███╗ █████╗  ██████╗███████╗
;; ██║   ██║██║        ██╔════╝████╗ ████║██╔══██╗██╔════╝██╔════╝
;; ╚██╗ ██╔╝██║        █████╗  ██╔████╔██║███████║██║     ███████╗
;;  ╚████╔╝ ██║        ██╔══╝  ██║╚██╔╝██║██╔══██║██║     ╚════██║
;;   ╚██╔╝  ██████╗    ███████╗██║ ╚═╝ ██║██║  ██║╚██████╗███████║
;;    ╚═╝   ╚═════╝    ╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝╚══════╝
;;
;;    Loading time : %s
;;    Features     : %s
"
                      (emacs-init-time)
                      (length features))))

    (message (emacs-init-time)))
  (:with-function vl/welcome
    (:hook-into after-init-hook)))
#+end_src

** Better ~keyboard-quit~
Based on Prot's [[https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/#h:1e468b2a-9bee-4571-8454-e3f5462d9321][Basic and capable configuration article]].

#+begin_src emacs-lisp :noweb-ref init-el
(setup vlaci-emacs
  (:global [remap keyboard-quit] #'vlaci-keyboard-quit-dwim))
#+end_src

#+begin_src emacs-lisp :noweb-ref vlaci-emacs
;;;###autoload
(defun vlaci-keyboard-quit-dwim ()
  "Do-What-I-Mean behaviour for a general `keyboard-quit'.

The generic `keyboard-quit' does not do the expected thing when
the minibuffer is open.  Whereas we want it to close the
minibuffer, even without explicitly focusing it.

The DWIM behaviour of this command is as follows:

- When the region is active, disable it.
- When a minibuffer is open, but not focused, close the minibuffer.
- When the Completions buffer is selected, close it.
- In every other case use the regular `keyboard-quit'."
  (interactive)
  (cond
   ((region-active-p)
    (keyboard-quit))
   ((derived-mode-p 'completion-list-mode) ;; Do I need this?
    (delete-completion-window))
   ((> (minibuffer-depth) 0)
    (abort-recursive-edit))
   (t
    (keyboard-quit))))
#+end_src

** Icons, icons, icons

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package nerd-icons))

(setup (:package nerd-icons-completion)
  (:with-function nerd-icons-completion-marginalia-setup
    (:hook-into marginalia-mode-hook)))

(setup (:package nerd-icons-corfu)
  (:with-feature corfu
    (:when-loaded
      (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))))

(setup (:package nerd-icons-dired)
  (:hook-into dired-mode-hook))
#+end_src

#+begin_src nix :noweb-ref emacs-packages
nerd-icons
nerd-icons-completion
nerd-icons-corfu
nerd-icons-dired
#+end_src

** Undo
#+caption: packages
#+begin_src nix :noweb-ref emacs-packages
undo-fu
undo-fu-session
vundo
#+end_src


#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package undo-fu)
  (:option undo-limit (* 80 1024 1024)
           undo-strong-limit (* 120 1024 1024)
           undo-outer-limit (* 360 1024 1024)))

(setup (:package undo-fu-session)
  (:with-mode undo-fu-session-global-mode
    (:hook-into on-first-buffer-hook)))

(setup (:package vundo)
  (:option vundo-compact-display t)
  (:bind [remap keyboard-quit] #'vundo-quit))
#+end_src

** Editing

#+begin_src emacs-lisp :noweb-ref init-el
(add-hook 'prog-mode-hook
          (defun setup-newline-h ()
            (local-set-key (kbd "RET") (or (key-binding (kbd "C-M-j"))
                                              (key-binding (kbd "M-j"))))))
#+end_src

*** Evil

#+caption: packages
#+begin_src nix :noweb-ref emacs-packages
evil
evil-collection
evil-mc
evil-multiedit
evil-iedit-state
evil-surround
#+end_src


#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package evil evil-collection)
  (:hook-into after-init-hook)
  (:option
   ;; Will be handled by evil-collections
   evil-want-keybinding nil
   ;; Make `Y` behave like `D`
   evil-want-Y-yank-to-eol t
   ;; Do not extend visual selection to whole lines for ex commands
   evil-ex-visual-char-range t
   ;; `*` and `#` selects symbols instead of words
   evil-symbol-word-search t
   ;; Only highlight in the current window
   evil-ex-interactive-search-highlight 'selected-window
   ;; Use vim-emulated search implementation
   evil-search-module 'evil-search
   ;; Do not spam with error messages
   evil-kbd-macro-suppress-motion-error t
   evil-undo-system 'undo-fu
   evil-visual-state-cursor 'hollow
   evil-visual-update-x-selection-p nil
   evil-move-cursor-back nil
   evil-move-beyond-eol t)
  (:also-load evil-collection)
  (:when-loaded
    (delete 'evil-mc evil-collection-mode-list)
    ;;; delay loading evil-collection modules until they are needed
    (dolist (mode evil-collection-mode-list)
      (dolist (req (or (cdr-safe mode) (list mode)))
        (with-eval-after-load req
          (message "Loading evil-collection for mode %s" req)
          (evil-collection-init (list mode)))))

    (evil-collection-init
     '(help
       (buff-menu "buff-menu")
       calc
       image
       elisp-mode
       replace
       (indent "indent")
       (process-menu simple)
       shortdoc
       tabulated-list
       tab-bar))

    (evil-global-set-key 'insert [remap evil-complete-next] #'complete-symbol))

  (define-advice evil-force-normal-state (:after (&rest _) vl/evil-force-normal-state-a)
    "Universal escape"
    (when (called-interactively-p 'any)
      (call-interactively #'vlaci-keyboard-quit-dwim))))

(defun vl/setup-evil-bind (bind-mode key command)
  (let ((map (setup-get 'map))
        (state (or (cdr (assq 'evil-state setup-opts)) 'motion))
        (mode (setup-get 'mode)))
      ;; We need to quote special symbols
    (when (member map '(global local))
        (setq map `(quote ,map)))
    (when bind-mode
      ;; evil-define-key will use map as a minor-mode name when quoted
      (setq map `(quote ,mode)))
    `(with-eval-after-load 'evil
       (evil-define-key ',state ,map ,key ,command))))

(setup-define :ebind
  (lambda (key command)
    (vl/setup-evil-bind nil key command))
  :documentation "Bind KEY to COMMAND for the given EVIL state"
  :repeatable t
  :indent 0)
(setup-define :ebind-mode
  (lambda (key command)
    (vl/setup-evil-bind t key command))
  :documentation "Bind KEY to COMMAND for the given EVIL state using current minor mode"
  :repeatable t
  :indent 0)

(setup-define :bind-mode
  (lambda (&rest body)
    (let (bodies)
      (push (setup-bind body (evil-bind-mode t)) bodies)
      (macroexp-progn (nreverse bodies))))
  :documentation "Use STATE for binding keys"
  :indent 0)
(setup-define :with-state
  (lambda (state &rest body)
    (let (bodies)
      (push (setup-bind body (evil-state state)) bodies)
      (macroexp-progn (nreverse bodies))))
  :documentation "Use STATE for binding keys"
  :indent 1)

(setup-define :evil
  (lambda (&rest body)
    `(:with-feature evil
      (:when-loaded
        (:with-state motion ,@body))))
  :documentation "Bind KEYs to COMMANDs for the given EVIL state"
  :ensure '(nil &rest kbd func)
  :indent 0)
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package evil-mc)
  (:option
   evil-mc-undo-cursors-on-keyboard-quit t)
  ;; from doomemacs
  (defvar evil-mc-key-map (make-sparse-keymap))
  (:autoload
   evil-mc-make-cursor-here
   evil-mc-make-all-cursors
   evil-mc-undo-all-cursors
   evil-mc-pause-cursors
   evil-mc-resume-cursors
   evil-mc-make-and-goto-first-cursor
   evil-mc-make-and-goto-last-cursor
   evil-mc-make-cursor-in-visual-selection-beg
   evil-mc-make-cursor-in-visual-selection-end
   evil-mc-make-cursor-move-next-line
   evil-mc-make-cursor-move-prev-line
   evil-mc-make-cursor-at-pos
   evil-mc-has-cursors-p
   evil-mc-undo-last-added-cursor
   evil-mc-make-and-goto-next-cursor
   evil-mc-skip-and-goto-next-cursor
   evil-mc-make-and-goto-prev-cursor
   evil-mc-skip-and-goto-prev-cursor
   evil-mc-make-and-goto-next-match
   evil-mc-skip-and-goto-next-match
   evil-mc-skip-and-goto-next-match
   evil-mc-make-and-goto-prev-match
   evil-mc-skip-and-goto-prev-match)
  (defvar-keymap vl/evil-mc-repeat-map
    :repeat (:exit
             (evil-mc-make-all-cursors)
             :hints
             ((evil-mc-make-and-goto-next-match . "▶")
              (evil-mc-make-and-goto-prev-match . "◀")
              (evil-mc-skip-and-goto-next-match . "⏭")
              (evil-mc-skip-and-goto-prev-match . "⏮")
              (evil-mc-make-all-cursors . "⛶")
              (evil-mc-make-cursor-here . "⊹")
              (evil-mc-undo-last-added-cursor . "↶")))
    "l" #'evil-mc-make-and-goto-next-match
    "L" #'evil-mc-make-and-goto-prev-match
    ">" #'evil-mc-skip-and-goto-next-match
    "<" #'evil-mc-skip-and-goto-prev-match
    "c" #'evil-mc-make-all-cursors
    "h" #'evil-mc-make-cursor-here
    "u" #'evil-mc-undo-last-added-cursor)
  (:with-state (normal visual)
    (:with-map evil-mc-key-map
      (:ebind
        "g." nil
        (kbd "C-n") #'evil-mc-make-and-goto-next-cursor
        (kbd "C-S-n") #'evil-mc-make-and-goto-last-cursor
        (kbd "C-p") #'evil-mc-make-and-goto-prev-cursor
        (kbd "C-S-p") #'evil-mc-make-and-goto-first-cursor))
    (:with-map global
      (:ebind
        "gc" vl/evil-mc-repeat-map)))


  (:when-loaded
    (add-hook 'evil-insert-state-entry-hook #'evil-mc-resume-cursors)
    ;; HACK evil-mc's design is bizarre. Its variables and hooks are lazy loaded
    ;;   rather than declared at top-level, some hooks aren't defined or
    ;;   documented, it's a bit initializer-function drunk, and its minor modes
    ;;   are intended to be perpetually active -- even when no cursors are active
    ;;   (causing #6021). I undo all of that here.
    (evil-mc-define-vars)
    (evil-mc-initialize-vars)
    (add-hook 'evil-mc-before-cursors-created #'evil-mc-pause-incompatible-modes)
    (add-hook 'evil-mc-before-cursors-created #'evil-mc-initialize-active-state)
    (add-hook 'evil-mc-after-cursors-deleted  #'evil-mc-teardown-active-state)
    (add-hook 'evil-mc-after-cursors-deleted  #'evil-mc-resume-incompatible-modes)
    (advice-add #'evil-mc-initialize-hooks :override #'ignore)
    (advice-add #'evil-mc-teardown-hooks :override #'evil-mc-initialize-vars)
    (advice-add #'evil-mc-initialize-active-state :before #'turn-on-evil-mc-mode)
    (advice-add #'evil-mc-teardown-active-state :after #'turn-off-evil-mc-mode)
    (define-advice evil-mc-mode (:around (fn &rest args) vl/evil-mc-dont-reinit-vars-a)
      (cl-letf (((symbol-function 'evil-mc-initialize-vars) #'ignore))
        (apply fn args)))))
#+end_src

** Navigation
#+caption: flake.nix:inputs
#+begin_src nix :noweb-ref flake-inputs
evil-ts-obj = { url = "github:vlaci/evil-ts-obj"; flake = false; };
treesit-jump = { url = "github:vlaci/treesit-jump"; flake = false; };
#+end_src

#+begin_src nix :noweb-ref emacs-packages
ace-window
avy
evil-snipe
(mkPackage {
  pname = "evil-ts-obj";
  src = inputs.evil-ts-obj;
  files = [ "lisp/*.el" ];
  packageRequires = [ avy evil ];
})
evil-textobj-tree-sitter
(mkPackage {
  pname = "treesit-jump";
  src = inputs.treesit-jump;
  files = [ "treesit-jump.el" "treesit-queries" ];
  packageRequires = [ avy ];
})
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package ace-window)
  (:option aw-keys '(?a ?r ?s ?t ?g ?n ?e ?i ?o)
           aw-dispatch-always t)
  (:global (kbd "M-o") #'ace-window))

(setup (:package avy)
  (:option avy-keys '(?a ?r ?s ?t ?d ?h ?n ?e ?i ?o ?w ?f ?p ?l ?u ?y))

  (:with-feature evil
    (:when-loaded
      (defvar avy-all-windows)
      (evil-define-motion vl/goto-char-timer-or-isearch (_count)
        :type inclusive
        :jump t
        :repat abort
        (evil-without-repeat
          (evil-enclose-avy-for-motion
            (when (eq (avy-goto-char-timer) t)
              (add-hook 'isearch-update-post-hook #'vl/isearch-update-hook t)
              (add-hook 'isearch-mode-end-hook #'vl/isearch-mode-end t)
              (isearch-mode t)
              (isearch-yank-string avy-text)))))))


   (defun vl/isearch-update-hook()
     (goto-char (match-beginning 0)))

   (defun vl/isearch-mode-end()
     (remove-hook 'isearch-update-post-hook 'vl-isearch-update-hook t)
     (remove-hook 'isearch-mode-end-hook 'vl-isearch-mode-end t))

   (advice-add 'avy-resume :after #'evil-normal-state)
   (:with-map global
     (:ebind
       "g/" #'vl/goto-char-timer-or-isearch)))

(setup (:package evil-ts-obj)
  (:hook-into
   bash-ts-mode-hook
   c-ts-mode-hook
   c++-ts-mode-hook
   nix-ts-mode-hook
   python-ts-mode-hook
   rust-ts-mode-hook
   yaml-ts-mode-hook)
  ;; replaced inject from s/S to i/I
  (:option
   evil-ts-obj-enabled-keybindings '(generic-navigation navigation text-objects avy))
  (:with-state (visual normal)
    (:ebind-mode
      "zx" #'evil-ts-obj-swap
      "zR" #'evil-ts-obj-replace
      "zr" #'evil-ts-obj-raise
      "zc" #'evil-ts-obj-clone-after
      "zC" #'evil-ts-obj-clone-before
      "zt" #'evil-ts-obj-teleport-after
      "zT" #'evil-ts-obj-teleport-before
      "zE" #'evil-ts-obj-extract-up
      "ze" #'evil-ts-obj-extract-down
      "zi" #'evil-ts-obj-inject-down
      "zI" #'evil-ts-obj-inject-up))
  (:with-state normal
    (:ebind-mode
      (kbd "M-r") #'evil-ts-obj-raise-dwim
      (kbd "M-j") #'evil-ts-obj-drag-down
      (kbd "M-k") #'evil-ts-obj-drag-up
      (kbd "M-c") #'evil-ts-obj-clone-after-dwim
      (kbd "M-C") #'evil-ts-obj-clone-before-dwim
      (kbd "M-h") #'evil-ts-obj-extract-up-dwim
      (kbd "M-l") #'evil-ts-obj-extract-down-dwim
      (kbd "M-i") #'evil-ts-obj-inject-down-dwim
      (kbd "M-I") #'evil-ts-obj-inject-up-dwim
      (kbd "M->") #'evil-ts-obj-slurp
      (kbd "M-<") #'evil-ts-obj-barf)))

(setup (:package evil-textobj-tree-sitter)
  (defmacro vl/evil-textobj-goto (group &optional previous end query)
    `(defun ,(intern (format "vl/evil-textobj-goto-%s%s%s" (if previous "previous-" "") (if end "end-" "") group)) ()
       (interactive)
       (evil-textobj-tree-sitter-goto-textobj ,group ,previous ,end ,query)))
  (:with-map global
    (:ebind
      ;;"]a" param.outer is bound by evil-ts-obj
      "]c" (vl/evil-textobj-goto "comment.outer")
      "]d" (vl/evil-textobj-goto "function.outer")
      "]D" (vl/evil-textobj-goto "call.outer")
      "]C" (vl/evil-textobj-goto "class.outer")
      "]v" (vl/evil-textobj-goto "conditional.outer")
      "]l" (vl/evil-textobj-goto "loop.outer")
      ;;"[a" param.outer is bound by evil-ts-obj
      "[c" (vl/evil-textobj-goto "comment.outer" t)
      "[d" (vl/evil-textobj-goto "function.outer" t)
      "[D" (vl/evil-textobj-goto "call.outer" t)
      "[C" (vl/evil-textobj-goto "class.outer" t)
      "[v" (vl/evil-textobj-goto "conditional.outer" t)
      "[l" (vl/evil-textobj-goto "loop.outer")))
  (:with-map evil-outer-text-objects-map
    (:ebind
      "A" (evil-textobj-tree-sitter-get-textobj ("parameter.outer" "call.outer"))
      "f" (evil-textobj-tree-sitter-get-textobj "function.outer")
      "F" (evil-textobj-tree-sitter-get-textobj "call.outer")
      "C" (evil-textobj-tree-sitter-get-textobj "class.outer")
      "c" (evil-textobj-tree-sitter-get-textobj "comment.outer")
      "v" (evil-textobj-tree-sitter-get-textobj "conditional.outer")
      "l" (evil-textobj-tree-sitter-get-textobj "loop.outer")))
  (:with-map evil-inner-text-objects-map
    (:ebind
      "A" (evil-textobj-tree-sitter-get-textobj ("parameter.inner" "call.inner"))
      "f" (evil-textobj-tree-sitter-get-textobj "function.inner")
      "F" (evil-textobj-tree-sitter-get-textobj "call.inner")
      "C" (evil-textobj-tree-sitter-get-textobj "class.inner")
      "c" (evil-textobj-tree-sitter-get-textobj "comment.inner")
      "v" (evil-textobj-tree-sitter-get-textobj "conditional.inner")
      "l" (evil-textobj-tree-sitter-get-textobj "loop.inner"))))

(setup (:package treesit-jump)
   (:with-map global
     (:ebind "zj" #'treesit-jump-jump)))

(setup (:package evil-snipe)
  (:hook-into on-first-input-hook)
  (:with-mode evil-snipe-override-mode
    (:hook-into on-first-input-hook))
  (:option evil-snipe-override-evil-repeat-keys nil
           evil-snipe-scope 'visible
           evil-snipe-repeat-scope 'whole-visible
           evil-snipe-smart-case t
           evil-snipe-tab-increment t))
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup xref
  (:with-map global
    (:ebind
      "gd" #'xref-find-definitions
      "gA" #'xref-find-references
      "gs" #'xref-find-apropos)))

(setup flymake
  (:ebind-mode
    "g]" #'flymake-goto-next-error
    "g[" #'flymake-goto-prev-error))

(setup emacs
  (:with-map global
    (:ebind
      "gh" #'display-local-help)))

#+end_src


** Completion

#+caption: packages
#+begin_src nix :noweb-ref emacs-packages
vertico
vertico-posframe
orderless
marginalia
consult
corfu
cape
embark
embark-consult
wgrep
#+end_src

From [[https://github.com/minad/vertico?tab=readme-ov-file#configuration][its README]].

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package vertico vertico-posframe)
  (:with-mode (vertico-mode vertico-multiform-mode)
    (:hook-into on-first-input-hook))
  (:with-map minibuffer-local-map
    (:bind [escape] #'keyboard-quit))
  (:option vertico-scroll-margin 0
           vertico-count 17
           vertico-resize t
           vertico-cycle t
           vertico-multiform-categories  '((t
                                            posframe
                                            (vertico-posframe-poshandler . posframe-poshandler-frame-top-center)
                                            (vertico-posframe-fallback-mode . vertico-buffer-mode)))
           vertico-posframe-width 100))

;; A few more useful configurations...
(setup emacs
  (:option
   ;; Support opening new minibuffers from inside existing minibuffers.
   enable-recursive-minibuffers t
   ;; Hide commands in M-x which do not work in the current mode.  Vertico
   ;; commands are hidden in normal buffers. This setting is useful beyond
   ;; Vertico.
   read-extended-command-predicate #'command-completion-default-include-p)
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))
#+end_src

Based on [[https://github.com/minad/consult/wiki#minads-orderless-configuration][Minad's configuration]]:

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package orderless)
  (defun vl/orderless--consult-suffix ()
    "Regexp which matches the end of string with Consult tofu support."
    (if (and (boundp 'consult--tofu-char) (boundp 'consult--tofu-range))
        (format "[%c-%c]*$"
                consult--tofu-char
                (+ consult--tofu-char consult--tofu-range -1))
      "$"))

  ;; Recognizes the following patterns:
  ;; * .ext (file extension)
  ;; * regexp$ (regexp matching at end)
  (defun vl/orderless-consult-dispatch (word _index _total)
    (cond
     ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
     ((string-suffix-p "$" word)
      `(orderless-regexp . ,(concat (substring word 0 -1) (vl/orderless--consult-suffix))))
     ;; File extensions
     ((and (or minibuffer-completing-file-name
               (derived-mode-p 'eshell-mode))
           (string-match-p "\\`\\.." word))
      `(orderless-regexp . ,(concat "\\." (substring word 1) (vl/orderless--consult-suffix))))))

  (:once 'on-first-input-hook
         (:require orderless)
         ;; Define orderless style with initialism by default
         (orderless-define-completion-style vl/orderless-with-initialism
           (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp))))

  ;; Certain dynamic completion tables (completion-table-dynamic) do not work
  ;; properly with orderless. One can add basic as a fallback.  Basic will only
  ;; be used when orderless fails, which happens only for these special
  ;; tables. Also note that you may want to configure special styles for special
  ;; completion categories, e.g., partial-completion for files.
  (:option completion-styles '(orderless basic)
           completion-category-defaults nil
        ;;; Enable partial-completion for files.
        ;;; Either give orderless precedence or partial-completion.
        ;;; Note that completion-category-overrides is not really an override,
        ;;; but rather prepended to the default completion-styles.
           ;; completion-category-overrides '((file (styles orderless partial-completion))) ;; orderless is tried first
           completion-category-overrides '((file (styles partial-completion)) ;; partial-completion is tried first
                                           ;; enable initialism by default for symbols
                                           (command (styles vl/orderless-with-initialism))
                                           (variable (styles vl/orderless-with-initialism))
                                           (symbol (styles vl/orderless-with-initialism)))
           orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
           orderless-style-dispatchers (list #'vl/orderless-consult-dispatch
                                             #'orderless-affix-dispatch)))
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package marginalia)
  (:hook-into after-init-hook)
  (:with-map minibuffer-local-map
    (:bind "M-A" marginalia-cycle)))
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package consult)
  (:global ;; C-c bindings in `mode-specific-map'
   "C-c M-x" consult-mode-command
   "C-c h" consult-history
   "C-c k" consult-kmacro
   "C-c m" consult-man
   "C-c i" consult-info
   [remap Info-search] #'consult-info
   ;; C-x bindings in `ctl-x-map'
   "C-x M-:" consult-complex-command     ;; orig. repeat-complex-command
   "C-x b" consult-buffer                ;; orig. switch-to-buffer
   "C-x 4 b" consult-buffer-other-window ;; orig. switch-to-buffer-other-window
   "C-x 5 b" consult-buffer-other-frame  ;; orig. switch-to-buffer-other-frame
   "C-x t b" consult-buffer-other-tab    ;; orig. switch-to-buffer-other-tab
   "C-x r b" consult-bookmark            ;; orig. bookmark-jump
   "C-x p b" consult-project-buffer      ;; orig. project-switch-to-buffer
   ;; Custom M-# bindings for fast register access
   "M-#" consult-register-load
   "M-'" consult-register-store          ;; orig. abbrev-prefix-mark (unrelated
   "C-M-#" consult-register
   ;; Other custom bindings
   "M-y" consult-yank-pop                ;; orig. yank-pop
   ;; M-g bindings in `goto-map'
   "M-g e" consult-compile-error
   "M-g f" consult-flymake               ;; Alternative: consult-flycheck
   "M-g g" consult-goto-line             ;; orig. goto-line
   "M-g M-g" consult-goto-line           ;; orig. goto-line
   "M-g o" consult-outline               ;; Alternative: consult-org-heading
   "M-g m" consult-mark
   "M-g k" consult-global-mark
   "M-g i" consult-imenu
   "M-g I" consult-imenu-multi
   ;; M-s bindings in `search-map'
   "M-s d" consult-fd                  ;; Alternative: consult-find
   "M-s c" consult-locate
   "M-s g" consult-grep
   "M-s G" consult-git-grep
   "M-s r" consult-ripgrep
   "M-s l" consult-line
   "M-s L" consult-line-multi
   "M-s k" consult-keep-lines
   "M-s u" consult-focus-lines
   ;; Isearch integration
   "M-s e" consult-isearch-history)
  (:with-map isearch-mode-map
    (:bind
     "M-e" consult-isearch-history         ;; orig. isearch-edit-string
     "M-s e" consult-isearch-history       ;; orig. isearch-edit-string
     "M-s l" consult-line                  ;; needed by consult-line to detect isearch
     "M-s L" consult-line-multi))            ;; needed by consult-line to detect isearch
  ;; Minibuffer history
  (:with-map minibuffer-local-map
    (:bind
     "M-s" consult-history                 ;; orig. next-matching-history-element
     "M-r" consult-history))                ;; orig. previous-matching-history-element

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI.
  (:with-mode consult-preview-at-point-mode
    (:hook-into completion-list-mode))

  ;; Tweak the register preview for `consult-register-load',
  ;; `consult-register-store' and the built-in commands.  This improves the
  ;; register formatting, adds thin separator lines, register sorting and hides
  ;; the window mode line.
  (advice-add #'register-preview :override #'consult-register-window)
  (setq register-preview-delay 0.5)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  (:when-loaded
    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key "M-.")
    ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; "C-+"

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (keymap-set consult-narrow-map (concat consult-narrow-key " ?") #'consult-narrow-help)
    ))
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package corfu)
  (:with-mode global-corfu-mode
    (:hook-into on-first-input-hook))
  (:with-mode corfu-popupinfo-mode
    (:hook-into on-first-input-hook)))

(setup emacs
  ;; TAB cycle if there are only few candidates
  ;; (completion-cycle-threshold 3)

  ;; Enable indentation+completion using the TAB key.
  ;; `completion-at-point' is often bound to M-TAB.
  (:option tab-always-indent 'complete
           ;; Emacs 30 and newer: Disable Ispell completion function.
           ;; Try `cape-dict' as an alternative.
           text-mode-ispell-word-completion nil
           ;; Hide commands in M-x which do not apply to the current mode.  Corfu
           ;; commands are hidden, since they are not used via M-x. This setting is
           ;; useful beyond Corfu.
           read-extended-command-predicate #'command-completion-default-include-p))

;; Use Dabbrev with Corfu!
(setup dabbrev
  ;; Swap M-/ and C-M-/
  (:global "M-/" dabbrev-completion
           "C-M-/" dabbrev-expand)
  (:when-loaded
    (add-to-list 'dabbrev-ignored-buffer-regexps "\\` ")
    ;; Since 29.1, use `dabbrev-ignored-buffer-regexps' on older.
    (add-to-list 'dabbrev-ignored-buffer-modes 'doc-view-mode)
    (add-to-list 'dabbrev-ignored-buffer-modes 'pdf-view-mode)
    (add-to-list 'dabbrev-ignored-buffer-modes 'tags-table-mode)))
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package embark)
  (:option embark-indicators
           '(embark-minimal-indicator  ; default is embark-mixed-indicator
             embark-highlight-indicator
             embark-isearch-highlight-indicator))

  (:with-feature vertico
    (:when-loaded
      (add-to-list 'vertico-multiform-categories '(embark-keybinding grid))))

  (setq prefix-help-command #'embark-prefix-help-command)
  (:global [remap describe-bindings] #'embark-bindings
           "C-;" #'embark-act
           "M-." #'embark-dwim)
  (:with-map minibuffer-local-map
    (:bind "C-;" #'embark-act)))
#+end_src


** Tree-Sitter

#+begin_src nix :noweb-ref emacs-packages
(treesit-grammars.with-grammars (
  grammars:
  with pkgs.lib;
  pipe grammars [
    (filterAttrs (name: _: name != "recurseForDerivations"))
    builtins.attrValues
  ]
))
treesit-auto
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package treesit-auto)
  (:autoload 'global-treesit-auto-mode)
  (:with-mode global-treesit-auto-mode
    (:hook-into after-init-hook))
  (:when-loaded
    (delete 'dockerfile treesit-auto-langs)
    (treesit-auto-add-to-auto-mode-alist 'all)))
#+end_src

** LSP

#+caption: flake.nix:inputs
#+begin_src nix :noweb-ref flake-inputs
emacs-lsp-booster = { url = "github:blahgeek/emacs-lsp-booster"; flake = false; };
#+end_src

#+begin_src nix :noweb-ref emacs-package-overrides :prologue "(" :epilogue ")"
final: prev:

{
  emacs-lsp-booster = pkgs.rustPlatform.buildRustPackage rec {
    pname = "emacs-lsp-booster";
    version = "0.2.1";
    src = inputs.emacs-lsp-booster;
    cargoLock = {
      lockFile = "${src}/Cargo.lock";
    };
    doCheck = false;
  };
}
#+end_src

#+begin_src nix :noweb-ref emacs-packages
dape
#+end_src


#+begin_src nix :noweb-ref emacs-packages
lsp-mode
lsp-ui
consult-lsp
yasnippet
#+end_src

#+begin_src nix :noweb-ref emacs-package-overrides :prologue "(" :epilogue ")"
final: prev:

{
  lsp-mode = prev.lsp-mode.overrideAttrs (_: {
    postPatch = ''
      substituteInPlace lsp-protocol.el \
        --replace '(getenv "LSP_USE_PLISTS")' 't'
    '';
  });
}
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package lsp-mode)
  (:option lsp-use-plist t
           lsp-keymap-prefix "C-c l"
           lsp-diagnostics-provider :flymake
           lsp-completion-provider :none
           lsp-modeline-diagnostics-enable nil
           lsp-hearline-breadrcumb-enable nil)
  (:ebind-mode
    "gD" #'lsp-find-declaration
    "gy" #'lsp-find-type-definition
    "gI" #'lsp-find-implementation)
  (:with-state normal
    (:ebind-mode
      "g." #'lsp-execute-code-action))
  (:with-state operator
    (:ebind-mode
     "d" '(menu-item
           ""
           nil
           :filter (lambda (&rest _)
                     (when (eq evil-this-operator 'evil-change)
                       #'lsp-rename)))))
  (:with-state insert
    (:ebind-mode
      (kbd "C-.") #'lsp-execute-code-action))
  (:when-loaded
    (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\.jj\\'")))

(setup (:package lsp-ui)
  (:option lsp-ui-doc-position 'top
           lsp-ui-doc-show-with-mouse nil
           lsp-ui-sideline-enable nil)
  (:ebind-mode
    [remap xref-find-definitions] #'lsp-ui-peek-find-definitions
    [remap xref-find-references] #'lsp-ui-peek-find-references))

(setup (:package yasnippet)
  (:with-mode yas-global-mode
    (:hook-into on-first-input-hook)))

(setup (:package consult-lsp)
  (:with-mode lsp-mode
    (:bind [remap xref-find-apropos] #'consult-lsp-symbols)
    (:ebind-mode
      "gs" #'consult-lsp-file-symbols
      "gS" #'consult-lsp-symbols)))

(setup-define :lsp
  (lambda ()
    `(:hook lsp-deferred))
  :documentation "Configure LSP")

(define-advice lsp-resolve-final-command (:around (old-fn cmd &optional test?) vl/lsp-resolve-final-command-lsp-booster-a)
  "Prepend emacs-lsp-booster command to lsp CMD."
  (let ((orig-result (funcall old-fn cmd test?)))
    (if (and (not test?)                             ;; for check lsp-server-present?
             (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
             lsp-use-plists
             (not (functionp 'json-rpc-connection))  ;; native json-rpc
             (executable-find "emacs-lsp-booster"))
        (progn
          (message "Using emacs-lsp-booster for %s!" orig-result)
          (append (list "emacs-lsp-booster" "--disable-bytecode" "--") orig-result))
      orig-result)))
#+end_src


#+begin_src nix :noweb-ref emacs-nixpkgs
emacs-lsp-booster
#+end_src

** Dired

#+begin_src emacs-lisp :noweb-ref init-el
(setup dired
  (:option dired-listing-switches "-Alh --group-directories-first --time-style=iso"
           dired-kill-when-opening-new-dired-buffer t)
  (:global "M-i" vl/window-dired-vc-root-left)
  (:bind "C-<return>" vl/window-dired-open-directory)

  (defun vl/window-dired-vc-root-left (&optional directory-path)
    "Creates *Dired-Side* like an IDE side explorer"
    (interactive)
    (add-hook 'dired-mode-hook 'dired-hide-details-mode)

    (let ((dir (if directory-path
                   (dired-noselect directory-path)
                 (if (eq (vc-root-dir) nil)
                     (dired-noselect default-directory)
                   (dired-noselect (vc-root-dir))))))

      (display-buffer-in-side-window
       dir `((side . left)
             (slot . 0)
             (window-width . 30)
             (window-parameters . ((no-other-window . t)
                                   (no-delete-other-windows . t)
                                   (mode-line-format . (" "
                                                        "%b"))))))
      (with-current-buffer dir
        (let ((window (get-buffer-window dir)))
          (when window
            (select-window window)
            (rename-buffer "*Dired-Side*"))))))

  (defun vl/window-dired-open-directory ()
    "Open the current directory in *Dired-Side* side window."
    (interactive)
    (vl/window-dired-vc-root-left (dired-get-file-for-visit))))
#+end_src

#+begin_src nix :noweb-ref emacs-packages
dirvish
pdf-tools
#+end_src

#+begin_src nix :noweb-ref emacs-nixpkgs
vips
ffmpegthumbnailer
mediainfo
epub-thumbnailer
p7zip
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package dirvish)
  (:when-loaded (dirvish-override-dired-mode)))
#+end_src

** Languages

#+begin_src nix :noweb-ref emacs-packages
eldev
nix-ts-mode
markdown-mode
just-ts-mode
polymode
rust-mode
dockerfile-mode
lsp-pyright
#+end_src

#+begin_src nix :noweb-ref emacs-nixpkgs
nil
llvmPackages.clang-tools
rust-analyzer
basedpyright
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package polymode))

(add-to-list 'auto-mode-alist '("\\.nix" . ordenada-nix-polymode))

(setup (:package nix-ts-mode)
  (define-hostmode poly-nix-hostmode
    :mode 'nix-mode)
  (define-auto-innermode poly-nix-dynamic-innermode
                         :head-matcher (rx "#" blank (+ (any "a-z" "-")) (+ (any "\n" blank)) "''\n")
                         :tail-matcher (rx bol (+ blank) "'';")
                         :mode-matcher (cons (rx "#" blank (group (+ (any "a-z" "-"))) (* anychar)) 1)
                         :head-mode 'host
                         :tail-mode 'host)

  (define-innermode poly-nix-interpolation-innermode
                    :mode 'nix-mode
                    :head-matcher (rx "${")
                    :tail-matcher #'pm-forward-sexp-tail-matcher
                    :head-mode 'body
                    :tail-mode 'body
                    :can-nest t)

  (define-polymode poly-nix-mode
                   :hostmode 'poly-nix-hostmode
                   :innermodes '(poly-nix-dynamic-innermode))

  (:with-mode poly-nix-mode
    (:file-match "\\.nix\\'"))
  (defalias 'nix-mode 'nix-ts-mode) ;; For org-mode code blocks to work
  (:lsp))

(setup (:package rust-ts-mode)
  (:lsp)
  (:option rust-mode-treesitter-derive t)
  (:hook (defun vl/remove-rust-ts-flymake-diagnostic-function-h()
           (remove-hook 'flymake-diagnostic-functions #'rust-ts-flymake 'local))))

(setup (:package lsp-pyright)
  (:option lsp-pyright-langserver-command "basedpyright")
  (:with-mode python-base-mode
    (:when-loaded
      (:require lsp-pyright))))

(setup python-ts-mode
  (:lsp))

(setup c-or-c++-ts-mode
  (:lsp))

(setup (:package just-ts-mode)
  (define-hostmode poly-just-hostmode
    :mode 'just-ts-mode)

  (defun vlaci/poly-get-innermode-for-exe (re)
    (re-search-forward re (point-at-eol) t)
    (let ((exe (match-string-no-properties 1)))
      (cond ((equal exe "emacs") "emacs-lisp")
            (t exe))))

  (define-auto-innermode poly-just-innermode
                         :head-matcher (rx bol (+ (any blank)) "#!" (+ (any "a-z0-9_/ -")) "\n")
                         :tail-matcher #'pm-same-indent-tail-matcher
                         :mode-matcher (apply-partially #'vlaci/poly-get-innermode-for-exe (rx (+? anychar) "bin/env " (? "-S ") (group (+ (any "a-z-"))) (* anychar)))
                         :head-mode 'host
                         :tail-mode 'host)

  (define-auto-innermode poly-just-script-innermode
                         :head-matcher (rx bol "[script('" (+? anychar) ":" (* (not "\n")) "\n")
                         :tail-matcher #'pm-same-indent-tail-matcher
                         :mode-matcher (apply-partially #'vlaci/poly-get-innermode-for-exe (rx bol "[script('" (group (+ (not "'"))) (* anychar)))
                         :head-mode 'host
                         :tail-mode 'host)

  (define-polymode poly-just-mode
                   :hostmode 'poly-just-hostmode
                   :innermodes '(poly-just-innermode poly-just-script-innermode))

  (:with-mode poly-just-mode
    (:file-match (rx (or "justfile" ".just") string-end))))

(setup (:package markdown-mode))
#+end_src

** Direnv

#+begin_src nix :noweb-ref emacs-packages
envrc
#+end_src

Customizations are lifted from doomemacs

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package envrc)
  (:with-mode envrc-global-mode
    (:hook-into on-first-file-hook))

  (defun vl/direnv-init-global-mode-earlier-h ()
    (let ((fn #'envrc-global-mode-enable-in-buffer))
      (if (not envrc-global-mode)
          (remove-hook 'change-major-mode-after-body-hook fn)
        (remove-hook 'after-change-major-mode-hook fn)
        (add-hook 'change-major-mode-after-body-hook fn 100))))
  (add-hook 'envrc-global-mode-hook #'vl/direnv-init-global-mode-earlier-h)

  (defvar vl/orig-exec-path exec-path)
  (define-advice envrc--update (:around (fn &rest args) vl/envrc--debounce-add-extra-path-a)
    "Update only on non internal envrc related buffers keeping original path entries as well"
    (when (not (string-prefix-p "*envrc" (buffer-name)))
      (apply fn args)
      (setq-local exec-path (append exec-path vl/orig-exec-path)))))
#+end_src

** Spell-checking

#+begin_src nix :noweb-ref emacs-packages
jinx
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package jinx)
  (:with-mode global-jinx-mode
    (:hook-into on-first-buffer-hook))
  (:option jinx-languages "en_US hu_HU")
  (:ebind-mode
    [remap evil-next-flyspell-error] #'jinx-next
    [remap evil-prev-flyspell-error] #'jinx-previous
    [remap ispell-word] #'jinx-correct)
  (:when-loaded
    (add-to-list 'vertico-multiform-categories
                 '(jinx grid (vertico-grid-annotate . 20)))))
#+end_src

** Magit

#+begin_src nix :noweb-ref emacs-packages
magit
diff-hl
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package magit)
  (:option magit-prefer-remote-upstream t
           magit-save-repository-buffers nil
           magit-diff-refine-hunk t
           magit-define-global-key-bindings 'recommended
           git-commit-major-mode 'markdown-mode)

  (:when-loaded
    (transient-append-suffix 'magit-pull "-r"
      '("-a" "Autostash" "--autostash"))
    (transient-append-suffix 'magit-commit "-n"
      '("-s" "Dont show status" "--no-status"))
    (add-to-list 'font-lock-ignore '(git-commit-mode markdown-fontify-headings)))

  (:with-feature magit-commit
    (:when-loaded
      (transient-replace-suffix 'magit-commit 'magit-commit-autofixup
        '("x" "Absorb changes" magit-commit-absorb))
      (setq transient-levels '((magit-commit (magit-commit-absorb . 1))))))

  (:with-feature project
    (:when-loaded
      (define-key project-prefix-map "m" #'magit-project-status)
      (add-to-list 'project-switch-commands '(magit-project-status "Magit") t)))

  (:with-feature smerge-mode
    (:when-loaded
      (map-keymap
       (lambda (_key cmd)
         (when (symbolp cmd)
           (put cmd 'repeat-map 'smerge-basic-map)))
       smerge-basic-map))))
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup ediff
  (:option ediff-keep-variants nil
           ediff-split-window-function #'split-window-horizontally
           ediff-window-setup-function #'ediff-setup-windows-plain))
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package diff-hl)
  (:with-mode global-diff-hl-mode
    (:hook-into on-first-buffer-hook))
  (:with-mode diff-hl-dired-mode
    (:hook-into dired-mode-hook))
  (define-advice diff-hl-define-bitmaps (:after (&rest _) vl/diff-hl-thin-bitmaps-a)
    (let* ((scale (if (and (boundp 'text-scale-mode-amount)
                           (numberp text-scale-mode-amount))
                      (expt text-scale-mode-step text-scale-mode-amount)
                    1))
           (spacing (or (and (display-graphic-p) (default-value 'line-spacing)) 0))
           (h (+ (ceiling (* (frame-char-height) scale))
                 (if (floatp spacing)
                     (truncate (* (frame-char-height) spacing))
                   spacing)))
           (w (min (frame-parameter nil (intern (format "%s-fringe" diff-hl-side)))
                   16))
           (_ (if (zerop w) (setq w 16))))
      (define-fringe-bitmap 'diff-hl-bmp-middle
        (make-vector
         h (string-to-number (let ((half-w (1- (/ w 2))))
                               (concat (make-string half-w ?1)
                                       (make-string (- w half-w) ?0)))
                             2))
        nil nil 'center)))
  (defun vl/diff-hl-type-at-pos-fn (type _pos)
    (if (eq type 'delete)
        'diff-hl-bmp-delete
      'diff-hl-bmp-middle))
  (setq diff-hl-fringe-bmp-function #'vl/diff-hl-type-at-pos-fn)
  (setq diff-hl-draw-borders nil)
  (:hook (defun vl/make-diff-hl-faces-transparent-h ()
           (set-face-background 'diff-hl-insert nil)
           (set-face-background 'diff-hl-delete nil)
           (set-face-background 'diff-hl-change nil))))
#+end_src

** Formatting

#+begin_src emacs-lisp :noweb-ref init-el
(setup emacs
  (:option indent-tabs-mode nil
           mouse-yank-at-point t)) ;; paste at keyboard cursor instead of mouse pointer location
#+end_src

#+begin_src nix :noweb-ref emacs-packages
apheleia
#+end_src

#+begin_src nix :noweb-ref emacs-nixpkgs
nixfmt-rfc-style
nodePackages.prettier
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package apheleia)
  (:with-mode apheleia-global-mode
    (:hook-into on-first-file-hook))
  (:when-loaded
    ;; do not use apheleia-npx wrapper
    (dolist (key (list
                  'prettier
                  'prettier-css
                  'prettier-html
                  'prettier-graphql
                  'prettier-javascript
                  'prettier-json
                  'prettier-markdown
                  'prettier-ruby
                  'prettier-scss
                  'prettier-scsss
                  'prettier-svelte
                  'pretter-typescript
                  'prettier-yaml))
      (setf (alist-get key apheleia-formatters) (cdr (alist-get key apheleia-formatters))))
    (setf (alist-get 'ruff-check apheleia-formatters) (list "ruff" "check" "--fix" "--exit-zero" "-"))
    (setf (alist-get 'ruff-format apheleia-formatters) (list "ruff" "format" "-"))
    (setf (alist-get 'rustfmt apheleia-formatters) (list "rustfmt" "--quiet" "--emit" "stdout" "--edition" "2024"))
    (setf (alist-get 'python-mode apheleia-mode-alist) '(ruff-check ruff-format))
    (setf (alist-get 'python-ts-mode apheleia-mode-alist) '(ruff-check ruff-format))))
#+end_src

** Passwords
#+begin_src nix :noweb-ref emacs-packages
auth-source-1password
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package auth-source-1password)
  (:with-function auth-source-1password-enable
    (:hook-into on-first-buffer-hook))
  (:option auth-source-1password-vault "Emacs"))
#+end_src

** AI

#+begin_src nix :noweb-ref emacs-packages
gptel
chatgpt-shell
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package chatgpt-shell)
  (:option
   chatgpt-shell-perplexity-api-key
   (lambda() (auth-source-pick-first-password :host "Perplexity" :user "credential"))))

(setup (:package gptel)
  (:when-loaded
    (:option gptel-model   'sonar
             gptel-backend (gptel-make-perplexity "Perplexity"
                                                  :key (lambda() (auth-source-pick-first-password :host "Perplexity" :user "credential"))
                                                  :stream t))))
#+end_src

** Projects

#+begin_src emacs-lisp :noweb-ref init-el
(setup project
  (define-advice project-current (:around (fun &rest args) vl/project-current-per-frame-a)
    (let ((proj (frame-parameter nil 'vl/project-current)))
      (unless proj
        (setq proj (apply fun args))
        (modify-frame-parameters nil `((vl/project-current . ,proj))))
      proj))

  (define-advice project-switch-project (:before (&rest _) vl/project-switch-project-per-frame-a)
    (modify-frame-parameters nil '((vl/project-current . nil)))))
#+end_src

** [[id:77550a15-8c6e-40e0-9930-d97c043a9de1][Eshell]]

** Eat terminal

#+begin_src nix :noweb-ref emacs-packages
eat
#+end_src

#+begin_src emacs-lisp :noweb-ref init-el
(setup (:package eat)
  (add-hook 'eshell-load-hook #'eat-eshell-mode))
#+end_src

#+begin_src nix :noweb-ref home-manager-modules :prologue "(" :epilogue ")"
{ lib, ...}:

{
  programs.zsh.initContent = lib.mkBefore ''
    [[ -n "$EAT_SHELL_INTEGRATION_DIR" ]] &&
      source "$EAT_SHELL_INTEGRATION_DIR/zsh"
  '';
}
#+end_src
